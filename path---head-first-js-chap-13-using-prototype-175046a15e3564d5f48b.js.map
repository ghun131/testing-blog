{"version":3,"sources":["webpack:///path---head-first-js-chap-13-using-prototype-175046a15e3564d5f48b.js","webpack:///./.cache/json/head-first-js-chap-13-using-prototype.json"],"names":["webpackJsonp","366","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,q/HAA60HC,aAA8LC,KAAA,eAAAC,KAAA,wCAAAC,MAAA,+CAA2HC","file":"path---head-first-js-chap-13-using-prototype-175046a15e3564d5f48b.js","sourcesContent":["webpackJsonp([65236670772965],{\n\n/***/ 366:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><em>Phần này nói về prototype-based object - một loại object khác với class-based của Java hay C++ (mấy thứ mà mình không biết đó)</em></p>\\n<p>Tưởng tượng ta có một object constructor Dog khiểu như thế này</p>\\n<pre><code class=\\\"language-javascript\\\">function Dog(name, breed, weight) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n    this.bark = function() {\\n        if(this.weight > 25) {\\n            alert(this.name + \\\" says Woof!\\\");\\n        } else {\\n             alert (this.name + \\\" say Yip!\\\");\\n        }\\n    };\\n}\\n</code></pre>\\n<p>Nó có 3 properties (name, breed và weight) và một thuộc tính (bark). Giờ tạo ra 3 object như sau:</p>\\n<pre><code class=\\\"language-javascript\\\">var fido = new Dog('Fido', 'Mixed', 38);\\nvar fluffy = new Dog('Fluffy', 'Poodle', 30);\\nvar spot = new Dog('Spot', 'Chihuahua', 10);\\n</code></pre>\\n<p>Với mỗi một object, ta có một method bark. Giả sử có tầm 1,000 object thì cũng có nghĩa là cần dùng 1,000 method bark (mỗi chó một cách sủa).\\nVì thế mà giờ, ta sẽ gộp tất cả các cách sủa lại làm 1 và để ở phần <em>prototype</em>, lần sau mỗi lần ta bảo \\\"fido\\\" sủa, browser sẽ chỉ đến prototype tìm method bark (sủa) thay vì tìm method này ở object fido.\\nGiờ sách bảo làm thế này:</p>\\n<pre><code class=\\\"language-javascript\\\">function Dog(name, breed, weight) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n}\\n\\nDog.prototype.species = 'Canine';\\nDog.prototype.bark = function() {\\n    if(this.weight > 25) {\\n        console.log(this.name + ' says Woof!');\\n    } else {\\n        console.log(this.name + ' says Yip!');\\n    }\\n};\\nDog.prototype.run = function() {\\n    console.log('Run');\\n};\\nDog.prototype.wag = function() {\\n    console.log('Wag!');\\n};\\n</code></pre>\\n<p>Okay vậy prototype rất tốt cho việc chỉnh sửa một lượng lớn object là ví dụ (instances) của một constructor nào đó. Thế nếu như chỉ chỉnh sửa một nhóm trong toàn bộ ví dụ đó thì sao. Giả sử như với \\\"Dog\\\" là toàn loài chó thì có những giống chó hoặc một dạng chó phục vụ một mục đích nhất định cứ cho là chó diễn xiếc như sách chọn gọi là \\\"ShowDog\\\"\\nĐầu tiên là khai báo các properties giống như của <code>Dog()</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">function ShowDog(name, breed, weight, handler) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n}\\n</code></pre>\\n<p>Tiếp đó là thêm property <code>handler</code> mà chỉ có <code>ShowDog()</code> có:</p>\\n<pre><code class=\\\"language-javascript\\\">    this.handler = handler;\\n</code></pre>\\n<p>Bước cuối để tạo constructor <code>ShowDog()</code> là khai báo tương tự như tạo object từ constructor:</p>\\n<pre><code class=\\\"language-javascript\\\">    ShowDog.prototype = new Dog();\\n</code></pre>\\n<p>Tuy nhiên theo DRY (don't repeat yourself) thì <code>ShowDog()</code> có lặp lại các bước tương tự như <code>Dog()</code>. Do đó ta dùng <code>call</code> method thay thế cho 3 dòng đầu khai báo properties. Viết lại như sau:</p>\\n<pre><code class=\\\"language-javascript\\\">function ShowDog(name, breed, weight, handler) {\\n    Dog.call(this, name, breed, weight);\\n    this.handler = handler;\\n}\\n</code></pre>\\n<p>Một người bạn bảo tôi rằng mọi thứ trong JavaScript đều là object. Có thể điều này không hoàn toàn đúng nhưng có một đoạn trong sách khiến tôi nghĩ rằng nó có lý. Cụ thể là với string ta có thể sử dụng các method build-in để thay đổi string đó. Hơn thế ta còn có thể điều chỉnh object <code>String</code> để tạo ra các method tùy ý. Ví dụ như đoạn code sau:</p>\\n<pre><code class=\\\"language-javascript\\\">String.prototype.cliche = function() {\\n    var cliche = ['lock and load', 'touch base', 'open the kimono'];\\n\\n    for (var i = 0; i &#x3C; cliche.length; i++) {\\n        var index = this.indexOf(cliche[i]);\\n        if (index >= 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n</code></pre>\\n<p>Khi này method <code>cliche</code> đã được thêm vào object <code>String</code>. Tuy nhiên ta lại không thể làm điều này với object <code>Array</code></p>\",\"frontmatter\":{\"date\":\"May 08, 2018\",\"path\":\"/head-first-js-chap13-using-prototype\",\"title\":\"Head first JS Chapter 13: Using Prototype\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---head-first-js-chap-13-using-prototype-175046a15e3564d5f48b.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><em>Phần này nói về prototype-based object - một loại object khác với class-based của Java hay C++ (mấy thứ mà mình không biết đó)</em></p>\\n<p>Tưởng tượng ta có một object constructor Dog khiểu như thế này</p>\\n<pre><code class=\\\"language-javascript\\\">function Dog(name, breed, weight) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n    this.bark = function() {\\n        if(this.weight > 25) {\\n            alert(this.name + \\\" says Woof!\\\");\\n        } else {\\n             alert (this.name + \\\" say Yip!\\\");\\n        }\\n    };\\n}\\n</code></pre>\\n<p>Nó có 3 properties (name, breed và weight) và một thuộc tính (bark). Giờ tạo ra 3 object như sau:</p>\\n<pre><code class=\\\"language-javascript\\\">var fido = new Dog('Fido', 'Mixed', 38);\\nvar fluffy = new Dog('Fluffy', 'Poodle', 30);\\nvar spot = new Dog('Spot', 'Chihuahua', 10);\\n</code></pre>\\n<p>Với mỗi một object, ta có một method bark. Giả sử có tầm 1,000 object thì cũng có nghĩa là cần dùng 1,000 method bark (mỗi chó một cách sủa).\\nVì thế mà giờ, ta sẽ gộp tất cả các cách sủa lại làm 1 và để ở phần <em>prototype</em>, lần sau mỗi lần ta bảo \\\"fido\\\" sủa, browser sẽ chỉ đến prototype tìm method bark (sủa) thay vì tìm method này ở object fido.\\nGiờ sách bảo làm thế này:</p>\\n<pre><code class=\\\"language-javascript\\\">function Dog(name, breed, weight) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n}\\n\\nDog.prototype.species = 'Canine';\\nDog.prototype.bark = function() {\\n    if(this.weight > 25) {\\n        console.log(this.name + ' says Woof!');\\n    } else {\\n        console.log(this.name + ' says Yip!');\\n    }\\n};\\nDog.prototype.run = function() {\\n    console.log('Run');\\n};\\nDog.prototype.wag = function() {\\n    console.log('Wag!');\\n};\\n</code></pre>\\n<p>Okay vậy prototype rất tốt cho việc chỉnh sửa một lượng lớn object là ví dụ (instances) của một constructor nào đó. Thế nếu như chỉ chỉnh sửa một nhóm trong toàn bộ ví dụ đó thì sao. Giả sử như với \\\"Dog\\\" là toàn loài chó thì có những giống chó hoặc một dạng chó phục vụ một mục đích nhất định cứ cho là chó diễn xiếc như sách chọn gọi là \\\"ShowDog\\\"\\nĐầu tiên là khai báo các properties giống như của <code>Dog()</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">function ShowDog(name, breed, weight, handler) {\\n    this.name = name;\\n    this.breed = breed;\\n    this.weight = weight;\\n}\\n</code></pre>\\n<p>Tiếp đó là thêm property <code>handler</code> mà chỉ có <code>ShowDog()</code> có:</p>\\n<pre><code class=\\\"language-javascript\\\">    this.handler = handler;\\n</code></pre>\\n<p>Bước cuối để tạo constructor <code>ShowDog()</code> là khai báo tương tự như tạo object từ constructor:</p>\\n<pre><code class=\\\"language-javascript\\\">    ShowDog.prototype = new Dog();\\n</code></pre>\\n<p>Tuy nhiên theo DRY (don't repeat yourself) thì <code>ShowDog()</code> có lặp lại các bước tương tự như <code>Dog()</code>. Do đó ta dùng <code>call</code> method thay thế cho 3 dòng đầu khai báo properties. Viết lại như sau:</p>\\n<pre><code class=\\\"language-javascript\\\">function ShowDog(name, breed, weight, handler) {\\n    Dog.call(this, name, breed, weight);\\n    this.handler = handler;\\n}\\n</code></pre>\\n<p>Một người bạn bảo tôi rằng mọi thứ trong JavaScript đều là object. Có thể điều này không hoàn toàn đúng nhưng có một đoạn trong sách khiến tôi nghĩ rằng nó có lý. Cụ thể là với string ta có thể sử dụng các method build-in để thay đổi string đó. Hơn thế ta còn có thể điều chỉnh object <code>String</code> để tạo ra các method tùy ý. Ví dụ như đoạn code sau:</p>\\n<pre><code class=\\\"language-javascript\\\">String.prototype.cliche = function() {\\n    var cliche = ['lock and load', 'touch base', 'open the kimono'];\\n\\n    for (var i = 0; i &#x3C; cliche.length; i++) {\\n        var index = this.indexOf(cliche[i]);\\n        if (index >= 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n</code></pre>\\n<p>Khi này method <code>cliche</code> đã được thêm vào object <code>String</code>. Tuy nhiên ta lại không thể làm điều này với object <code>Array</code></p>\",\"frontmatter\":{\"date\":\"May 08, 2018\",\"path\":\"/head-first-js-chap13-using-prototype\",\"title\":\"Head first JS Chapter 13: Using Prototype\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/head-first-js-chap-13-using-prototype.json\n// module id = 366\n// module chunks = 65236670772965"],"sourceRoot":""}